# -*- coding: utf-8 -*-
"""practise_oops.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WMRdZvSLgCNslyZ7iwvcowjoQDjVdESP
"""

class parents:
  def __init__(self, name,rating):
    self.p_name=name
    self.p_rating=rating

class print_parents(parents):
  parents_list=[]

  def reading(self):

    parents_list.append(self.p_name,self.p_rating)
    print(f" name :{self.p_name}\n rating: {self.p_rating}")

p=print_parents("jk",4)

p.reading()

q= print_parents("drake",3)
r=print_parents("eminem",5)
s=print_parents("rihanna",1)

from testing_1 import multiplication as multiplication

"""**Class POINT Class LINE**"""

class Point:
  def __init__(self,x,y):
    self.x_cod=x
    self.y_cod=y

  def __str__(self):
    return '<{},{}>'.format(self.x_cod,self.y_cod)

  def euclidean_distance(point_1,point_2):
    dist=((point_1.x_cod -point_2.x_cod)**2 + (point_1.y_cod-point_2.y_cod)**2)**0.5
    return print(f'distance between given point is {dist}')

  def distance_from_origin(p):
    # return (p.x_cod**2 +p.y_cod**2)**0.5
     return p.euclidean_distance(Point(0,0))

class Line:
  def __init__(self,A,B,C):
    self.line_a=A
    self.line_b=B
    self.line_c=C

  def __str__(self):
    return f'{self.line_a}x + {self.line_b}y + {self.line_c}=0'

  def point_on_line(line, point):
    value=line.line_a*point.x_cod + line.line_b*point.y_cod + line.line_c
    if value==0:
      return 'point lies on the line'

    else:
      return 'point does not lie on the line'

  def intersect_line(line1, line2):

l=Line(1,1,2)
print(l)

p=Point(-1,-1)

l.point_on_line(p)